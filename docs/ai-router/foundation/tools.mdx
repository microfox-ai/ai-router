---
title: 'Tools & Agent-as-Tools'
description: 'Learn about the new agent-as-tools pattern and how to expose agents as tools for LLM integration.'
---

## Overview

With the new **agent-as-tools** pattern, agents can be exposed as tools for LLM integration. This provides:

- **Type Safety**: Zod schemas for parameter validation
- **Reusability**: Agents can be called by multiple other agents or LLMs
- **Composability**: Agents can call other agents and be exposed as tools
- **Modularity**: Encapsulate complex functionality in reusable agent components
- **LLM Integration**: Seamless integration with `streamText`, `generateText`, and other AI SDK functions

## âš ï¸ Important: New Pattern

The old `router.tool()` method is **deprecated**. The new recommended approach is to create agents and expose them as tools using `.actAsTool()`.

### âœ… New Pattern (Recommended)

```typescript
import { AiRouter } from '@microfox/ai-router';
import { z } from 'zod';

// Create an agent and expose it as a tool
const calculatorAgent = new AiRouter();

calculatorAgent
  .agent('/', async (ctx) => {
    const { a, b, operation } = ctx.request.params;

    switch (operation) {
      case 'add':
        return { result: a + b };
      case 'subtract':
        return { result: a - b };
      case 'multiply':
        return { result: a * b };
      case 'divide':
        if (b === 0) throw new Error('Division by zero');
        return { result: a / b };
    }
  })
  .actAsTool('/', {
    id: 'calculator',
    name: 'Calculator',
    description: 'Performs basic arithmetic operations',
    inputSchema: z.object({
      a: z.number().describe('First number'),
      b: z.number().describe('Second number'),
      operation: z
        .enum(['add', 'subtract', 'multiply', 'divide'])
        .describe('Operation to perform'),
    }),
    outputSchema: z.object({
      result: z.number().describe('The calculation result'),
    }),
    metadata: {
      icon: 'ðŸ§®',
      title: 'Calculator',
    },
  });

// Mount the agent
router.agent('/calculator', calculatorAgent);
```

### âŒ Deprecated Pattern

```typescript
// âŒ DEPRECATED: Don't use this anymore
router.tool(
  '/calculator',
  {
    schema: z.object({
      a: z.number(),
      b: z.number(),
      operation: z.enum(['add', 'subtract', 'multiply', 'divide']),
    }),
    description: 'Performs basic arithmetic operations',
  },
  async (ctx, params) => {
    // ... tool logic
  },
);
```

## Using Agents as Tools

With the new pattern, you can call agents (which are exposed as tools) using `ctx.next.callAgent()`:

```typescript
router.agent('/math-agent', async (ctx) => {
  const result = await ctx.next.callAgent('/calculator', {
    a: 5,
    b: 3,
    operation: 'add',
  });

  if (result.ok) {
    return { message: `Result: ${result.data.result}` };
  } else {
    ctx.logger.error('Calculator failed:', result.error);
    return { error: 'Calculation failed', details: result.error.message };
  }
});
```

### âŒ Deprecated: Old Tool Calling

```typescript
// âŒ DEPRECATED: Don't use this anymore
router.agent('/math-agent', async (ctx) => {
  const result = await ctx.next.callTool('/calculator', {
    a: 5,
    b: 3,
    operation: 'add',
  });
  // ...
});
```

## Attaching Agents as Tools to LLM Functions

One of the most powerful features of AI Router is the ability to attach agents as tools to LLM functions like `generateText` and `streamText`. This allows the LLM to dynamically decide which agents to call based on the user's request, creating intelligent, agent-using systems.

### Basic Agent-as-Tool Attachment

You can attach agents as tools to LLM functions using `ctx.next.agentAsTool()`:

```typescript
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

router.agent('/smart-assistant', async (ctx) => {
  const { query } = ctx.request.params;

  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Answer this question: ${query}`,
    tools: {
      // Attach an agent as a tool
      calculator: ctx.next.agentAsTool('/calculator'),
      researcher: ctx.next.agentAsTool('/research'),
    },
  });

  return { response: text };
});
```

### âŒ Deprecated: Old Tool Attachment

```typescript
// âŒ DEPRECATED: Don't use this anymore
router.agent('/smart-assistant', async (ctx) => {
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Answer this question: ${query}`,
    tools: {
      // âŒ DEPRECATED: Old tool attachment
      calculator: ctx.next.attachTool('/calculator'),
    },
  });
  // ...
});
```

### Agent Composition

You can compose multiple agents for complex workflows:

```typescript
router.agent('/workflow-orchestrator', async (ctx) => {
  const { task } = ctx.request.params;

  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Complete this task: ${task}`,
    tools: {
      // Data gathering agents
      webSearch: ctx.next.agentAsTool('/web-search'),
      databaseQuery: ctx.next.agentAsTool('/database/query'),

      // Processing agents
      dataAnalyzer: ctx.next.agentAsTool('/data-analysis'),
      imageProcessor: ctx.next.agentAsTool('/image/process'),

      // Output agents
      reportGenerator: ctx.next.agentAsTool('/report-generation'),
      emailSender: ctx.next.agentAsTool('/email/send'),
    },
  });

  return { response: text };
});
```

### Optimize for Token Usage

Be mindful of token usage when attaching many agents as tools:

```typescript
// Only attach relevant agents based on the request
router.agent('/efficient-assistant', async (ctx) => {
  const { query, category } = ctx.request.params;

  let tools: Record<string, any> = {};

  // Attach agents based on request category
  switch (category) {
    case 'math':
      tools.calculator = ctx.next.agentAsTool('/calculator');
      break;
    case 'weather':
      tools.weather = ctx.next.agentAsTool('/weather');
      break;
    case 'research':
      tools.researcher = ctx.next.agentAsTool('/research');
      break;
    default:
      // Attach all agents for general queries
      tools = {
        calculator: ctx.next.agentAsTool('/calculator'),
        weather: ctx.next.agentAsTool('/weather'),
        researcher: ctx.next.agentAsTool('/research'),
      };
  }

  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: query,
    tools,
  });

  return { response: text };
});
```

## Agent-as-Tool Attachment vs Direct Agent Calls

**Use Agent-as-Tool Attachment when:**

- You want the LLM to intelligently decide which agents to use
- The user's request is ambiguous or could benefit from multiple agents
- You're building conversational interfaces
- You want to reduce the complexity of your agent logic

**Use Direct Agent Calls when:**

- You know exactly which agent to call based on the request
- You need precise control over agent execution order
- You're building deterministic workflows
- You want to minimize LLM token usage

```typescript
// Direct agent call - deterministic
router.agent('/deterministic', async (ctx) => {
  const { a, b, operation } = ctx.request.params;
  const result = await ctx.next.callAgent('/calculator', { a, b, operation });
  return { message: `Result: ${result.data.result}` };
});

// Agent-as-tool attachment - intelligent
router.agent('/intelligent', async (ctx) => {
  const { query } = ctx.request.params;
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: query,
    tools: {
      calculator: ctx.next.agentAsTool('/calculator'),
      weather: ctx.next.agentAsTool('/weather'),
    },
  });
  return { response: text };
});
```

## Agent Parameter Validation

Agents exposed as tools automatically validate parameters against their schema:

```typescript
const userValidatorAgent = new AiRouter();

userValidatorAgent
  .agent('/', async (ctx) => {
    // Parameters are already validated by the schema
    const { email, age, preferences } = ctx.request.params;

    // Additional business logic validation
    if (email.includes('test')) {
      throw new Error('Test emails are not allowed');
    }

    return {
      valid: true,
      user: { email, age, preferences: preferences || [] },
    };
  })
  .actAsTool('/', {
    id: 'userValidator',
    name: 'User Validator',
    description: 'Validates user data',
    inputSchema: z.object({
      email: z.string().email().describe('User email address'),
      age: z.number().min(18).max(120).describe('User age'),
      preferences: z.array(z.string()).optional().describe('User preferences'),
    }),
    outputSchema: z.object({
      valid: z.boolean().describe('Whether the user data is valid'),
      user: z
        .object({
          email: z.string(),
          age: z.number(),
          preferences: z.array(z.string()),
        })
        .describe('Validated user data'),
    }),
    metadata: {
      icon: 'âœ…',
      title: 'User Validator',
    },
  });

router.agent('/user-validator', userValidatorAgent);
```

## Best Practices

### 1. Use Descriptive Names and Descriptions

Make agents easy to understand and use:

```typescript
// Good
const paymentCalculatorAgent = new AiRouter();
paymentCalculatorAgent
  .agent('/', async (ctx) => {
    // ... payment calculation logic
  })
  .actAsTool('/', {
    id: 'paymentCalculator',
    name: 'Payment Calculator',
    description:
      'Calculates monthly mortgage payment based on principal, rate, and term',
    // ...
  });

// Avoid
const calcAgent = new AiRouter();
calcAgent
  .agent('/', async (ctx) => {
    // ... calculation logic
  })
  .actAsTool('/', {
    id: 'calc',
    name: 'Calculator',
    description: 'Does math',
    // ...
  });
```

### 2. Validate Input Thoroughly

Use comprehensive schemas to catch errors early:

```typescript
const userCreatorAgent = new AiRouter();
userCreatorAgent
  .agent('/', async (ctx) => {
    // ... user creation logic
  })
  .actAsTool('/', {
    id: 'userCreator',
    name: 'User Creator',
    description: 'Creates new user accounts',
    inputSchema: z.object({
      email: z.string().email().describe('User email address'),
      name: z.string().min(1).max(100).describe('User full name'),
      age: z.number().int().positive().max(120).describe('User age'),
      preferences: z
        .object({
          newsletter: z.boolean().describe('Subscribe to newsletter'),
          theme: z
            .enum(['light', 'dark', 'auto'])
            .describe('UI theme preference'),
        })
        .optional()
        .describe('User preferences'),
    }),
    // ...
  });
```

### 3. Handle Errors Gracefully

Provide meaningful error messages and handle edge cases:

```typescript
const fileProcessorAgent = new AiRouter();
fileProcessorAgent
  .agent('/', async (ctx) => {
    try {
      const { filePath } = ctx.request.params;

      if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
      }

      const content = await fs.promises.readFile(filePath, 'utf8');
      return { processed: processFile(content) };
    } catch (error) {
      ctx.logger.error('File processing failed:', error);
      throw new Error(`Failed to process file: ${error.message}`);
    }
  })
  .actAsTool('/', {
    id: 'fileProcessor',
    name: 'File Processor',
    description: 'Processes files and extracts content',
    // ...
  });
```

### 4. Keep Agents Focused

Each agent should have a single, well-defined responsibility:

```typescript
// Good: Single responsibility
const emailValidatorAgent = new AiRouter();
emailValidatorAgent
  .agent('/', async (ctx) => {
    // ... email validation logic
  })
  .actAsTool('/', {
    id: 'emailValidator',
    name: 'Email Validator',
    description: 'Validates email format and checks if domain exists',
    // ...
  });

// Avoid: Multiple responsibilities
const userManagerAgent = new AiRouter();
userManagerAgent
  .agent('/', async (ctx) => {
    // ... complex user management logic
  })
  .actAsTool('/', {
    id: 'userManager',
    name: 'User Manager',
    description: 'Creates, updates, deletes, validates, and processes users',
    // ...
  });
```

## Next Steps

- Learn about [Agent-as-Tools](/ai-router/foundation/agent-as-tool) for detailed agent-as-tool patterns
- Explore [State Management](/ai-router/foundation/state) for shared data across agents
- Understand [Middleware](/ai-router/foundation/middleware) for cross-cutting concerns
- See [Advanced Routing](/ai-router/advanced/routing) for complex scenarios
- Check [Error Handling](/ai-router/advanced/error-handling) for robust applications
- Review [Best Practices](/ai-router/advanced/best-practices) for building robust applications
