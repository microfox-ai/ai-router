import path from 'path';
import fs from 'fs-extra';
import { AiRouter } from '@microfox/ai-router';
import chalk from 'chalk';
import { build } from 'esbuild';
import { Project } from 'ts-morph';

// Helper to recursively remove schema properties
const removeSchemas = (obj: any): any => {
  if (Array.isArray(obj)) {
    return obj.map(removeSchemas);
  }
  if (obj !== null && typeof obj === 'object') {
    const newObj: any = {};
    for (const key in obj) {
      if (key !== 'inputSchema' && key !== 'outputSchema') {
        newObj[key] = removeSchemas(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
};

async function findRouterInstance(
  filePath: string,
  tempBuildDir: string,
): Promise<AiRouter<any, any, any, any, any, any>> {
  const outfile = path.join(tempBuildDir, 'router.cjs');

  await build({
    entryPoints: [filePath],
    bundle: true,
    outfile: outfile,
    platform: 'node',
    format: 'cjs',
    target: 'node18',
    plugins: [
      {
        name: 'make-all-packages-external',
        setup(build) {
          const filter = /^[^./]/;
          build.onResolve({ filter }, (args) => {
            if (!args.importer) {
              return;
            }
            return {
              path: args.path,
              external: true,
            };
          });
        },
      },
    ],
  });

  delete require.cache[require.resolve(outfile)];
  const module = require(outfile);

  for (const exportName in module) {
    const exported = module[exportName];
    if (
      exported &&
      typeof exported.registry === 'function' &&
      exported.actAsToolDefinitions instanceof Map
    ) {
      return exported;
    }
  }

  throw new Error(
    `Could not find an exported AiRouter instance in ${filePath}. Make sure it's a default or named export.`,
  );
}

export async function generateRegistry(
  projectDir: string,
  entryFile: string,
  outputDir: string,
  options?: { stripSchemas?: boolean },
) {
  const entryPath = path.resolve(projectDir, entryFile);
  const outputDirResolved = path.resolve(projectDir, outputDir);
  const tempBuildDir = path.join(projectDir, '.ai-router-build-temp');

  try {
    await fs.ensureDir(tempBuildDir);
    await fs.ensureDir(outputDirResolved);

    // 0) Generate RAW expanded types via ts-morph (no imports in final file)
    const project = new Project({
      compilerOptions: {
        target: 99,
        module: 99,
        skipLibCheck: true,
        esModuleInterop: true,
        allowJs: false,
        declaration: false,
        allowImportingTsExtensions: true,
      },
    });

    const relFromTempToEntry = path
      .relative(tempBuildDir, entryPath)
      .replace(/\\/g, '/');
    const relImportNoExt = relFromTempToEntry.replace(/\.(ts|tsx|js|jsx)$/i, '');

    const tempTypesSrcPath = path.join(tempBuildDir, '__ai_router_types_gen.ts');
    const tempTypesSrc = `import type { InferUITools } from 'ai';
import aiMainRouter from '${relImportNoExt}';
const _tools = aiMainRouter.registry().tools;
export type __AiRouterTools = InferUITools<typeof _tools>;
`;
    await fs.writeFile(tempTypesSrcPath, tempTypesSrc);

    const sourceFile = project.createSourceFile(
      tempTypesSrcPath,
      tempTypesSrc,
      { overwrite: true },
    );
    project.resolveSourceFileDependencies();

    const diagnostics = project.getPreEmitDiagnostics();
    if (diagnostics.length > 0) {
      console.log('[ai-router-cli][types] diagnostics count:', diagnostics.length);
      const first = diagnostics[0];
      console.log(
        '[ai-router-cli][types] first diagnostic:',
        (first as any).getMessageText && (first as any).getMessageText?.(),
      );
    }

    const typeAlias = sourceFile.getTypeAlias('__AiRouterTools');
    if (!typeAlias) {
      throw new Error('Failed to build AiRouterTools types: alias not found.');
    }
    const expandedTypeText = typeAlias.getType().getText(sourceFile);
    console.log(
      '[ai-router-cli][types] expanded type sample:',
      expandedTypeText.slice(0, 200),
    );

    let finalTypesText = expandedTypeText;
    if (!finalTypesText || finalTypesText.trim() === '' || finalTypesText.trim() === 'any') {
      console.log(
        '[ai-router-cli][types] Fallback: inferred type is any; generating minimal structural types from registry map after generation.',
      );
    }

    let typesDtsContent = `// This file is auto-generated by the ai-router build command. Do not edit.
export type AiRouterTools = ${finalTypesText || 'any'};
`;
    const typesDtsPath = path.join(outputDirResolved, 'types.d.ts');
    await fs.writeFile(typesDtsPath, typesDtsContent);
    console.log(
      chalk.green(
        `✅ Wrote types to ${path.relative(projectDir, typesDtsPath)}`,
      ),
    );

    // 1) Execute router and compute registry
    const aiMainRouter = await findRouterInstance(entryPath, tempBuildDir);

    const registry = aiMainRouter.registry();

    // If we fell back to any, build a structural type from registry.tools retaining schemas
    if (!finalTypesText || finalTypesText.trim() === '' || finalTypesText.trim() === 'any') {
      const toolKeys = Object.keys(registry.tools || {});
      const lines: string[] = [];
      lines.push('// This file is auto-generated by the ai-router build command. Do not edit.');
      lines.push('export type AiRouterTools = {');
      for (const key of toolKeys) {
        const tool = (registry.tools as any)[key] || {};
        const meta = tool.metadata || {};
        lines.push(`  ${JSON.stringify(key)}: {`);
        lines.push(`    id: ${JSON.stringify(tool.id ?? key)};`);
        lines.push(`    name: ${JSON.stringify(tool.name ?? '')};`);
        lines.push(`    description: ${JSON.stringify(tool.description ?? '')};`);
        lines.push('    metadata: {');
        lines.push('      absolutePath: string;');
        lines.push('      toolKey: string;');
        lines.push('      name: string;');
        lines.push('      description: string;');
        if (meta.icon !== undefined) lines.push('      icon?: string;');
        if (meta.title !== undefined) lines.push('      title?: string;');
        if (meta.parentTitle !== undefined || meta.parent !== undefined) lines.push('      parentTitle?: string;');
        if (meta.hideUI !== undefined) lines.push('      hideUI?: boolean;');
        lines.push('    };');
        // Keep schemas present in types view
        lines.push('    inputSchema?: unknown;');
        lines.push('    outputSchema?: unknown;');
        lines.push('  };');
      }
      lines.push('};');
      typesDtsContent = lines.join('\n') + '\n';
      await fs.writeFile(typesDtsPath, typesDtsContent);
      console.log('[ai-router-cli][types] Wrote fallback structural types from registry.tools');
    }

    // 2) Generate registry.ts (conditionally strip schemas)
    const registryForFile = options?.stripSchemas
      ? { ...registry, tools: removeSchemas(registry.tools) }
      : registry;

    const registryContent = `// This file is auto-generated by the ai-router build command. Do not edit.
export const aiRouterRegistry = ${JSON.stringify(
      registryForFile,
      null,
      2,
    )};
`;
    const registryPath = path.join(outputDirResolved, 'registry.ts');
    await fs.writeFile(registryPath, registryContent);
    console.log(
      chalk.green(`✅ Wrote registry to ${path.relative(projectDir, registryPath)}`),
    );
  } catch (error) {
    console.error(chalk.red('Error generating AI Router registry:'), error);
    process.exit(1);
  } finally {
    await fs.remove(tempBuildDir);
  }
}
